<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>阿狸的打字机</title>
      <link href="/2021/07/18/%E9%98%BF%E7%8B%B8%E7%9A%84%E6%89%93%E5%AD%97%E6%9C%BA/"/>
      <url>/2021/07/18/%E9%98%BF%E7%8B%B8%E7%9A%84%E6%89%93%E5%AD%97%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><h2 id="https-www-luogu-com-cn-problem-P2414"><a href="#https-www-luogu-com-cn-problem-P2414" class="headerlink" title="https://www.luogu.com.cn/problem/P2414"></a><a href="https://www.luogu.com.cn/problem/P2414">https://www.luogu.com.cn/problem/P2414</a></h2><br><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><ul><li><p>原题意简化为：询问 $x$串在 $y$ 串中的出现次数，多组询问</p></li><li><p>输入多个串的方式构成一棵 $trie$ 树，加入一个字符相当于从当前节点往下走一层，$P$ 标记当前节点为一个串的结尾 $B$ 返回父亲节点。不只应用于 $trie$ 树，这种输入 $dfs$ 序方法建树的套路，遇到不止一次了。  </p></li><li><p>$trie$ 树已经建好，又是字符串匹配问题，自然想到建出 $AC$ 自动机</p></li><li><p>考虑 $fail$ 树的意义：父亲节点必然是儿子节点的一个极大后缀（$kmp$ 失配数组同理）</p></li><li><p>那么对于 $y$ 串，我们一个个字符添加。如果加入一个字符后，$x$ 刚好出现，说明 $x$ 是 $y$ 的一个后缀。那么 $x$ 必然是 $y$ 在 $fail$ 树上的一个祖先。（不一定是极大后缀，不一定是父亲）</p></li><li><p>问题转化为，从根到 $y$ 结尾，对应在 $tire$ 树上的每个节点，有多少个节点能直接或间接地，通过爬 $fail$ 树，达到 $x$ 末尾节点。考虑用数据结构维护。</p></li><li><p>考虑逆问题，在 $x$ 的 $fail$ 子树内，有多少个结点是y串在trie树的节点？</p></li><li><p>我们知道子树问题可以转化为区间问题，对于节点 $x$ ，我们询问在 $fail$ 树上，入栈序和出栈序的区间 $[in[x], out[x]]$</p></li><li><p>在线处理询问，破坏了已经建成的 $trie$ 树的顺序和完整性，重复插入字符时间空间无法接受，考虑离线处理，按建 $trie$ 树每个串出现的顺序排序。算法呼之欲出了。</p></li></ul><ol><li>建出 $trie$、$fail$ 树，遍历 $fail$ 树得 $dfs$ 序</li><li>对询问按 $y$ 从小到大排序</li><li>再次按输入顺序遍历 $trie$ 树，进入、退出一个节点在 $fail$ 树上对应 $dfs$ 序节点 $+1$、$-1$</li><li>遇到 $P$ ，处理对当前 $y$ 的所有询问，用树状数组统计每个 $x$ 在 $fail$ 树上的子树和。</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><em>AC</em> 自动机的中难题，需要有非常深入的理解，理清楚 <em>fail</em> 树、<em>trie</em> 树之间的关系。并想到询问离线处理，有一定数据结构基础。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre class=" language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std;const int N = 2e5 + 50;int len, ans[N], in[N], out[N], dfn;struct Graph&#123;    int etop, head[N];    Graph () &#123;memset(head, -1, sizeof(head));&#125;    struct Edge    &#123;        int v, nxt;    &#125;e[N];    void add(int u, int v)    &#123;        e[++etop].v = v;        e[etop].nxt = head[u];        head[u] = etop;    &#125;    void dfs(int u)    &#123;        in[u] = ++dfn;        for (int i = head[u]; ~i; i = e[i].nxt)            dfs(e[i].v);        out[u] = dfn;    &#125;&#125;G;namespace BIT&#123;    int a[N];    void add(int pos, int val)    &#123;        for (int i = pos; i <= dfn; i += i & -i)            a[i] += val;    &#125;    int query(int pos)    &#123;        int ret = 0;        for (int i = pos; i; i -= i & -i)            ret += a[i];        return ret;    &#125;    int query(int l, int r)    &#123;        return query(r) - query(l - 1);    &#125;&#125;struct Query&#123;    int x, y, id;    void input(int _id)    &#123;        id = _id;        scanf("%d%d", &x, &y);    &#125;    bool operator <(const Query &t) const    &#123;        return y < t.y;    &#125;&#125;ask[N];namespace AC&#123;    int ch[N][26], top, fa[N], fail[N], num, pos[N];    void trie(char *s)    &#123;        int u = 0;        for (int v, i = 0; i < len; i++)        &#123;            if (s[i] == 'P')                pos[++num] = u;            else if (s[i] == 'B')                u = fa[u];            else            &#123;                v = s[i] - 'a';                if (!ch[u][v])                    ch[u][v] = ++top;                fa[ch[u][v]] = u;                u = ch[u][v];            &#125;        &#125;    &#125;    void build()    &#123;        queue <int> q;        for (int i = 0; i < 26; i++)            if (ch[0][i])            &#123;                q.push(ch[0][i]);                G.add(0, ch[0][i]);            &#125;        while (!q.empty())        &#123;            int u = q.front();            q.pop();            for (int v, i = 0; i < 26; i++)            &#123;                v = ch[u][i];                if (v)                &#123;                    fail[v] = ch[fail[u]][i];                    q.push(v);                    G.add(fail[v], v);                &#125;                else ch[u][i] = ch[fail[u]][i];            &#125;        &#125;        G.dfs(0);    &#125;    void work(char *s)    &#123;        int u = 0, cnt = 0, k = 1;        for (int i = 0; i < len; i++)        &#123;            if (s[i] == 'B')            &#123;                BIT::add(in[u], -1);                u = fa[u];            &#125;            else if (s[i] == 'P')            &#123;                ++cnt;                while (ask[k].y == cnt)                &#123;                    int x = pos[ask[k].x];                    ans[ask[k].id] = BIT::query(in[x], out[x]);                    ++k;                &#125;            &#125;            else             &#123;                u = ch[u][s[i] - 'a'];                BIT::add(in[u], 1);            &#125;        &#125;    &#125;&#125;char s[N];int main()&#123;    scanf("%s", s);    len = strlen(s);    AC::trie(s);    AC::build();    int m;    scanf("%d", &m);    for (int i = 1; i <= m; i++)        ask[i].input(i);    sort(ask + 1, ask + m + 1);    AC::work(s);    for (int i = 1; i <= m; i++)        printf("%d\n", ans[i]);    return 0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AC自动机 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
